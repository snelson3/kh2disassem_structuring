FN = "BLJM_66675.c"

dis = open(FN).read()

HEADER = """/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>

"""

F_DECS_HEADER = """//-------------------------------------------------------------------------
// Function declarations
"""

F_DATA_HEADER = """//-------------------------------------------------------------------------
// Data declarations"""

F_FN_HEADER = """//----- (""" 

h_start = dis.index(F_DECS_HEADER)
h_len = len(F_DECS_HEADER)
fnlist_start = h_start+h_len
fnlist_end = dis.index(F_DATA_HEADER)-1
fnlist = dis[fnlist_start:fnlist_end]
numfns = len(fnlist.split("\n"))
numfns
datalist_start = (fnlist_end + 1) + len(F_DATA_HEADER)
datalist_end = dis.index(F_FN_HEADER)-1
datalist = dis[datalist_start:datalist_end]





def clean_func_name(n):
    if len(n) == 0:
        return "diss_error"
    nr = n
    bookends = [("<", ">"),("{", "}"),("`","'")]
    for b in bookends:
        while b[0] in nr and b[1] in nr:
            front = nr[:nr.index(b[0])]
            back = nr[::-1]
            back = back[:back.index(b[1])][::-1]
            nr = front+back
            
    symbols = ["*","~","++"]
    for sym in symbols:
        nr = nr.replace(sym, "")
    nr = nr.replace("::::","::") # Handle the case where removing the type def gets rid of the whole section
    
    if nr.startswith("__std___"):
        nr = nr.replace("__std___", "unnamed::std::")
    if nr.startswith("__sti___"):
        nr = nr.replace("__sti___", "unnamed::sti::")
    return nr
functions = dis[datalist_end+1:]
PERC = 0.05
perc_modnum = PERC * numfns
fs = {}
c = 0
print("scanning {} functions".format(numfns))
while F_FN_HEADER in functions:
    c += 1
    if c % int(perc_modnum) == 0:
      print("{}/{} ({}%)".format(c,numfns,int((c/numfns)*100)))
    # Check if PERCENT done with the functions, give some output if so
    f_end = functions[1:].index(F_FN_HEADER)+1
    function = functions[:f_end]
    functions = functions[f_end+1:]
    
    fnlines = function.split("\n")
    if fnlines[1].startswith("//"):
        if fnlines[2].startswith("//"):
            raise Exception("Wrong")
        function_def_line = fnlines[2]
    else:
        function_def_line = fnlines[1]
        
    # I checked and there are only two functions where the stupid strategy doesn't work for getting the name
    if function_def_line == "FLOAT (*__fastcall pppGetBbox(unsigned int *mng))[4]":
        function_name = "pppGetBbox"
    elif function_def_line == "__int64 (__fastcall *__fastcall SQEX::CDev::Engine::Sd::Driver::Oscillator::Update(SQEX::CDev::Engine::Sd::Driver::Oscillator *this, int a2))()":
        function_name = "SQEX::CDev::Engine::Sd::Driver::Oscillator::Update"
    else:
        function_name_group = function_def_line.split("(")
        if "<" in function_name_group[0]:
            function_name_section = function_name_group[0][:function_name_group[0].index("<")] + function_name_group[0][function_name_group[0].index("<"):].replace(" ", "_")
        else:
           function_name_section = function_name_group[0]
        function_name = function_name_section.split(" ")[-1]
      
    
    function_name = clean_func_name(function_name)
    if function_name in fs:
        fs[function_name].append(function)
    else:
        fs[function_name] = [function]


import os
for k in fs:
    p = k.split("::")
    p[-1] += ".c"
    pth = os.path.join("source",*p)
    d = os.path.dirname(pth)
    
    if not os.path.isdir(d):
        os.makedirs(d)
    with open(pth,"w") as f:
        f.write("\n".join(fs[k]))
open(os.path.join("source","function_declarations"),"w").write(fnlist)
open(os.path.join("source","data_declarations"),"w").write(datalist)

print("100%")

